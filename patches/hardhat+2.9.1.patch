diff --git a/node_modules/hardhat/internal/core/providers/accounts.js b/node_modules/hardhat/internal/core/providers/accounts.js
index 78b33ed..8dc277b 100644
--- a/node_modules/hardhat/internal/core/providers/accounts.js
+++ b/node_modules/hardhat/internal/core/providers/accounts.js
@@ -125,6 +125,7 @@ class LocalAccountsProvider extends chainId_1.ProviderWrapperWithChainId {
             const privateKey = this._getPrivateKeyForAddress(txRequest.from);
             const chainId = await this._getChainId();
             const rawTransaction = await this._getSignedTransaction(txRequest, chainId, privateKey);
+            console.log('send_Transaction:',txRequest)
             return this._wrappedProvider.request({
                 method: "eth_sendRawTransaction",
                 params: [bufferToHex(rawTransaction)],
@@ -225,6 +226,13 @@ class SenderProvider extends wrapper_1.ProviderWrapper {
                 }
             }
         }
+        if (method === "eth_estimateGas"){
+          console.log("=== eth_estimateGas ===")
+          let res = this._wrappedProvider.request(args);
+          console.log('eth_estimateGas:',args)
+          console.log('response:',await res)
+          return res;
+        }
         return this._wrappedProvider.request(args);
     }
 }
diff --git a/node_modules/hardhat/internal/core/providers/http.js b/node_modules/hardhat/internal/core/providers/http.js
index 2d4904d..5eb70b8 100644
--- a/node_modules/hardhat/internal/core/providers/http.js
+++ b/node_modules/hardhat/internal/core/providers/http.js
@@ -51,6 +51,8 @@ class HttpProvider extends events_1.EventEmitter {
         const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);
         const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);
         if (isErrorResponse(jsonRpcResponse)) {
+            console.log('jsonRpcRequest:',jsonRpcRequest);
+            console.log('jsonRpcResponse:',jsonRpcResponse);
             error.message = jsonRpcResponse.error.message;
             error.code = jsonRpcResponse.error.code;
             error.data = jsonRpcResponse.error.data;
@@ -58,9 +60,13 @@ class HttpProvider extends events_1.EventEmitter {
             throw error;
         }
         if (args.method === "hardhat_reset") {
+            console.log('jsonRpcRequest:',jsonRpcRequest);
+            console.log('jsonRpcResponse:',jsonRpcResponse);
             this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);
         }
         if (args.method === "evm_revert") {
+            console.log('jsonRpcRequest:',jsonRpcRequest);
+            console.log('jsonRpcResponse:',jsonRpcResponse);
             this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);
         }
         return jsonRpcResponse.result;
diff --git a/node_modules/hardhat/src/internal/core/providers/backwards-compatibility.ts b/node_modules/hardhat/src/internal/core/providers/backwards-compatibility.ts
index 06a34e4..9b5f7c3 100644
--- a/node_modules/hardhat/src/internal/core/providers/backwards-compatibility.ts
+++ b/node_modules/hardhat/src/internal/core/providers/backwards-compatibility.ts
@@ -51,7 +51,9 @@ export class BackwardsCompatibilityProviderAdapter
       jsonrpc: "2.0",
     };
 
-    try {
+      console.log('send:',request.method,request.params)
+
+      try {
       response.result = await this._provider.request({
         method: request.method,
         params: request.params,
@@ -71,7 +73,7 @@ export class BackwardsCompatibilityProviderAdapter
         },
       };
     }
-
+    console.log('response:',response)
     return response;
   }
 }
diff --git a/node_modules/hardhat/src/internal/core/providers/gas-providers.ts b/node_modules/hardhat/src/internal/core/providers/gas-providers.ts
index e4d0e83..868fc68 100644
--- a/node_modules/hardhat/src/internal/core/providers/gas-providers.ts
+++ b/node_modules/hardhat/src/internal/core/providers/gas-providers.ts
@@ -210,7 +210,7 @@ export class AutomaticGasPriceProvider extends ProviderWrapper {
 
     tx.maxFeePerGas = numberToRpcQuantity(maxFeePerGas);
     tx.maxPriorityFeePerGas = numberToRpcQuantity(maxPriorityFeePerGas);
-
+    console.log('Automatic request:',args)
     return this._wrappedProvider.request(args);
   }
 
diff --git a/node_modules/hardhat/src/internal/core/providers/http.ts b/node_modules/hardhat/src/internal/core/providers/http.ts
index dc30f55..6d5882c 100644
--- a/node_modules/hardhat/src/internal/core/providers/http.ts
+++ b/node_modules/hardhat/src/internal/core/providers/http.ts
@@ -1,26 +1,26 @@
-import { EventEmitter } from "events";
-import { Dispatcher, Pool } from "undici";
+import {EventEmitter} from "events";
+import {Dispatcher, Pool} from "undici";
 
-import { EIP1193Provider, RequestArguments } from "../../../types";
+import {EIP1193Provider, RequestArguments} from "../../../types";
 import {
-  HARDHAT_NETWORK_RESET_EVENT,
-  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,
+    HARDHAT_NETWORK_RESET_EVENT,
+    HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,
 } from "../../constants";
 import {
-  FailedJsonRpcResponse,
-  JsonRpcRequest,
-  JsonRpcResponse,
-  parseJsonResponse,
-  SuccessfulJsonRpcResponse,
+    FailedJsonRpcResponse,
+    JsonRpcRequest,
+    JsonRpcResponse,
+    parseJsonResponse,
+    SuccessfulJsonRpcResponse,
 } from "../../util/jsonrpc";
-import { getHardhatVersion } from "../../util/packageInfo";
-import { HardhatError } from "../errors";
-import { ERRORS } from "../errors-list";
+import {getHardhatVersion} from "../../util/packageInfo";
+import {HardhatError} from "../errors";
+import {ERRORS} from "../errors-list";
 
-import { ProviderError } from "./errors";
+import {ProviderError} from "./errors";
 
 function isErrorResponse(response: any): response is FailedJsonRpcResponse {
-  return typeof response.error !== "undefined";
+    return typeof response.error !== "undefined";
 }
 
 const MAX_RETRIES = 6;
@@ -31,244 +31,247 @@ const TOO_MANY_REQUEST_STATUS = 429;
 const hardhatVersion = getHardhatVersion();
 
 export class HttpProvider extends EventEmitter implements EIP1193Provider {
-  private _nextRequestId = 1;
-  private _dispatcher: Dispatcher;
-  private _path: string;
-  private _authHeader: string | undefined;
-
-  constructor(
-    private readonly _url: string,
-    private readonly _networkName: string,
-    private readonly _extraHeaders: { [name: string]: string } = {},
-    private readonly _timeout = 20000,
-    client: Dispatcher | undefined = undefined
-  ) {
-    super();
-    const url = new URL(this._url);
-    this._path = url.pathname;
-    this._authHeader =
-      url.username === ""
-        ? undefined
-        : `Basic ${Buffer.from(
-            `${url.username}:${url.password}`,
-            "utf-8"
-          ).toString("base64")}`;
-    try {
-      this._dispatcher = client ?? new Pool(url.origin);
-    } catch (e) {
-      if (e instanceof TypeError && e.message === "Invalid URL") {
-        e.message += ` ${url.origin}`;
-      }
-      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
-      throw e;
-    }
-  }
-
-  public get url(): string {
-    return this._url;
-  }
-
-  public async request(args: RequestArguments): Promise<unknown> {
-    // We create the error here to capture the stack traces at this point,
-    // the async call that follows would probably loose of the stack trace
-    const error = new ProviderError("HttpProviderError", -1);
-
-    const jsonRpcRequest = this._getJsonRpcRequest(
-      args.method,
-      args.params as any[]
-    );
-    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);
-
-    if (isErrorResponse(jsonRpcResponse)) {
-      error.message = jsonRpcResponse.error.message;
-      error.code = jsonRpcResponse.error.code;
-      error.data = jsonRpcResponse.error.data;
-      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
-      throw error;
+    private _nextRequestId = 1;
+    private _dispatcher: Dispatcher;
+    private _path: string;
+    private _authHeader: string | undefined;
+
+    constructor(
+        private readonly _url: string,
+        private readonly _networkName: string,
+        private readonly _extraHeaders: { [name: string]: string } = {},
+        private readonly _timeout = 20000,
+        client: Dispatcher | undefined = undefined
+    ) {
+        super();
+        const url = new URL(this._url);
+        this._path = url.pathname;
+        this._authHeader =
+            url.username === ""
+                ? undefined
+                : `Basic ${Buffer.from(
+                    `${url.username}:${url.password}`,
+                    "utf-8"
+                ).toString("base64")}`;
+        try {
+            this._dispatcher = client ?? new Pool(url.origin);
+        } catch (e) {
+            if (e instanceof TypeError && e.message === "Invalid URL") {
+                e.message += ` ${url.origin}`;
+            }
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw e;
+        }
     }
 
-    if (args.method === "hardhat_reset") {
-      this.emit(HARDHAT_NETWORK_RESET_EVENT);
-    }
-    if (args.method === "evm_revert") {
-      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);
+    public get url(): string {
+        return this._url;
     }
 
-    return jsonRpcResponse.result;
-  }
-
-  /**
-   * Sends a batch of requests. Fails if any of them fails.
-   */
-  public async sendBatch(
-    batch: Array<{ method: string; params: any[] }>
-  ): Promise<any[]> {
-    // We create the errors here to capture the stack traces at this point,
-    // the async call that follows would probably loose of the stack trace
-    const error = new ProviderError("HttpProviderError", -1);
-
-    // we need this to sort the responses
-    const idToIndexMap: Record<string, number> = {};
-
-    const requests = batch.map((r, i) => {
-      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);
-      idToIndexMap[jsonRpcRequest.id] = i;
-      return jsonRpcRequest;
-    });
-
-    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);
-
-    for (const response of jsonRpcResponses) {
-      if (isErrorResponse(response)) {
-        error.message = response.error.message;
-        error.code = response.error.code;
-        error.data = response.error.data;
-        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
-        throw error;
-      }
-    }
+    public async request(args: RequestArguments): Promise<unknown> {
+        // We create the error here to capture the stack traces at this point,
+        // the async call that follows would probably loose of the stack trace
+        console.log("http.ts:",args)
+        const error = new ProviderError("HttpProviderError", -1);
 
-    // We already know that it has this type, but TS can't infer it.
-    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];
-
-    // we use the id to sort the responses so that they match the order of the requests
-    const sortedResponses = responses
-      .map(
-        (response) =>
-          [idToIndexMap[response.id], response.result] as [number, any]
-      )
-      .sort(([indexA], [indexB]) => indexA - indexB)
-      .map(([, result]) => result);
-
-    return sortedResponses;
-  }
-
-  private async _fetchJsonRpcResponse(
-    request: JsonRpcRequest,
-    retryNumber?: number
-  ): Promise<JsonRpcResponse>;
-  private async _fetchJsonRpcResponse(
-    request: JsonRpcRequest[],
-    retryNumber?: number
-  ): Promise<JsonRpcResponse[]>;
-  private async _fetchJsonRpcResponse(
-    request: JsonRpcRequest | JsonRpcRequest[],
-    retryNumber?: number
-  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;
-  private async _fetchJsonRpcResponse(
-    request: JsonRpcRequest | JsonRpcRequest[],
-    retryNumber = 0
-  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {
-    try {
-      const response = await this._dispatcher.request({
-        method: "POST",
-        path: this._path,
-        body: JSON.stringify(request),
-        maxRedirections: 10,
-        headersTimeout:
-          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined
-            ? 0
-            : this._timeout,
-        headers: {
-          "Content-Type": "application/json",
-          "User-Agent": `hardhat ${hardhatVersion}`,
-          Authorization: this._authHeader,
-          ...this._extraHeaders,
-        },
-      });
-
-      if (this._isRateLimitResponse(response)) {
-        // "The Fetch Standard allows users to skip consuming the response body
-        // by relying on garbage collection to release connection resources.
-        // Undici does not do the same. Therefore, it is important to always
-        // either consume or cancel the response body."
-        // https://undici.nodejs.org/#/?id=garbage-collection
-        // It's not clear how to "cancel", so we'll just consume:
-        await response.body.text();
-        const seconds = this._getRetryAfterSeconds(response);
-        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {
-          return await this._retry(request, seconds, retryNumber);
+        const jsonRpcRequest = this._getJsonRpcRequest(
+            args.method,
+            args.params as any[]
+        );
+        const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);
+        console.log("jsonRpcRequest:", jsonRpcRequest)
+        console.log("jsonRpcResponse:", jsonRpcResponse)
+        if (isErrorResponse(jsonRpcResponse)) {
+            error.message = jsonRpcResponse.error.message;
+            error.code = jsonRpcResponse.error.code;
+            error.data = jsonRpcResponse.error.data;
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw error;
         }
 
-        const url = new URL(this._url);
+        if (args.method === "hardhat_reset") {
+            this.emit(HARDHAT_NETWORK_RESET_EVENT);
+        }
+        if (args.method === "evm_revert") {
+            this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);
+        }
 
-        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
-        throw new ProviderError(
-          `Too Many Requests error received from ${url.hostname}`,
-          -32005 // Limit exceeded according to EIP1474
-        );
-      }
-
-      return parseJsonResponse(await response.body.text());
-    } catch (error: any) {
-      if (error.code === "ECONNREFUSED") {
-        throw new HardhatError(
-          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,
-          { network: this._networkName },
-          error
-        );
-      }
+        return jsonRpcResponse.result;
+    }
+
+    /**
+     * Sends a batch of requests. Fails if any of them fails.
+     */
+    public async sendBatch(
+        batch: Array<{ method: string; params: any[] }>
+    ): Promise<any[]> {
+        console.log("sendBatch")
+        // We create the errors here to capture the stack traces at this point,
+        // the async call that follows would probably loose of the stack trace
+        const error = new ProviderError("HttpProviderError", -1);
+
+        // we need this to sort the responses
+        const idToIndexMap: Record<string, number> = {};
+
+        const requests = batch.map((r, i) => {
+            const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);
+            idToIndexMap[jsonRpcRequest.id] = i;
+            return jsonRpcRequest;
+        });
+
+        const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);
+
+        for (const response of jsonRpcResponses) {
+            if (isErrorResponse(response)) {
+                error.message = response.error.message;
+                error.code = response.error.code;
+                error.data = response.error.data;
+                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+                throw error;
+            }
+        }
+
+        // We already know that it has this type, but TS can't infer it.
+        const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];
 
-      if (error.type === "request-timeout") {
-        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);
-      }
+        // we use the id to sort the responses so that they match the order of the requests
+        const sortedResponses = responses
+            .map(
+                (response) =>
+                    [idToIndexMap[response.id], response.result] as [number, any]
+            )
+            .sort(([indexA], [indexB]) => indexA - indexB)
+            .map(([, result]) => result);
 
-      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
-      throw error;
+        return sortedResponses;
     }
-  }
-
-  private async _retry(
-    request: JsonRpcRequest | JsonRpcRequest[],
-    seconds: number,
-    retryNumber: number
-  ) {
-    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));
-    return this._fetchJsonRpcResponse(request, retryNumber + 1);
-  }
-
-  private _getJsonRpcRequest(
-    method: string,
-    params: any[] = []
-  ): JsonRpcRequest {
-    return {
-      jsonrpc: "2.0",
-      method,
-      params,
-      id: this._nextRequestId++,
-    };
-  }
-
-  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {
-    if (retryNumber > MAX_RETRIES) {
-      return false;
+
+    private async _fetchJsonRpcResponse(
+        request: JsonRpcRequest,
+        retryNumber?: number
+    ): Promise<JsonRpcResponse>;
+    private async _fetchJsonRpcResponse(
+        request: JsonRpcRequest[],
+        retryNumber?: number
+    ): Promise<JsonRpcResponse[]>;
+    private async _fetchJsonRpcResponse(
+        request: JsonRpcRequest | JsonRpcRequest[],
+        retryNumber?: number
+    ): Promise<JsonRpcResponse | JsonRpcResponse[]>;
+    private async _fetchJsonRpcResponse(
+        request: JsonRpcRequest | JsonRpcRequest[],
+        retryNumber = 0
+    ): Promise<JsonRpcResponse | JsonRpcResponse[]> {
+        try {
+            const response = await this._dispatcher.request({
+                method: "POST",
+                path: this._path,
+                body: JSON.stringify(request),
+                maxRedirections: 10,
+                headersTimeout:
+                    process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined
+                        ? 0
+                        : this._timeout,
+                headers: {
+                    "Content-Type": "application/json",
+                    "User-Agent": `hardhat ${hardhatVersion}`,
+                    Authorization: this._authHeader,
+                    ...this._extraHeaders,
+                },
+            });
+
+            if (this._isRateLimitResponse(response)) {
+                // "The Fetch Standard allows users to skip consuming the response body
+                // by relying on garbage collection to release connection resources.
+                // Undici does not do the same. Therefore, it is important to always
+                // either consume or cancel the response body."
+                // https://undici.nodejs.org/#/?id=garbage-collection
+                // It's not clear how to "cancel", so we'll just consume:
+                await response.body.text();
+                const seconds = this._getRetryAfterSeconds(response);
+                if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {
+                    return await this._retry(request, seconds, retryNumber);
+                }
+
+                const url = new URL(this._url);
+
+                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+                throw new ProviderError(
+                    `Too Many Requests error received from ${url.hostname}`,
+                    -32005 // Limit exceeded according to EIP1474
+                );
+            }
+
+            return parseJsonResponse(await response.body.text());
+        } catch (error: any) {
+            if (error.code === "ECONNREFUSED") {
+                throw new HardhatError(
+                    ERRORS.NETWORK.NODE_IS_NOT_RUNNING,
+                    {network: this._networkName},
+                    error
+                );
+            }
+
+            if (error.type === "request-timeout") {
+                throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);
+            }
+
+            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error
+            throw error;
+        }
     }
 
-    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {
-      return false;
+    private async _retry(
+        request: JsonRpcRequest | JsonRpcRequest[],
+        seconds: number,
+        retryNumber: number
+    ) {
+        await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));
+        return this._fetchJsonRpcResponse(request, retryNumber + 1);
     }
 
-    return true;
-  }
+    private _getJsonRpcRequest(
+        method: string,
+        params: any[] = []
+    ): JsonRpcRequest {
+        return {
+            jsonrpc: "2.0",
+            method,
+            params,
+            id: this._nextRequestId++,
+        };
+    }
 
-  private _isRateLimitResponse(response: Dispatcher.ResponseData) {
-    return response.statusCode === TOO_MANY_REQUEST_STATUS;
-  }
+    private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {
+        if (retryNumber > MAX_RETRIES) {
+            return false;
+        }
 
-  private _getRetryAfterSeconds(
-    response: Dispatcher.ResponseData
-  ): number | undefined {
-    const header = response.headers["retry-after"];
+        if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {
+            return false;
+        }
 
-    if (header === undefined || header === null) {
-      return undefined;
+        return true;
     }
 
-    const parsed = parseInt(header, 10);
-    if (isNaN(parsed)) {
-      return undefined;
+    private _isRateLimitResponse(response: Dispatcher.ResponseData) {
+        return response.statusCode === TOO_MANY_REQUEST_STATUS;
     }
 
-    return parsed;
-  }
+    private _getRetryAfterSeconds(
+        response: Dispatcher.ResponseData
+    ): number | undefined {
+        const header = response.headers["retry-after"];
+
+        if (header === undefined || header === null) {
+            return undefined;
+        }
+
+        const parsed = parseInt(header, 10);
+        if (isNaN(parsed)) {
+            return undefined;
+        }
+
+        return parsed;
+    }
 }
